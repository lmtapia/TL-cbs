Language "TL"

#3 Statements

Syntax 
<<<<<<< HEAD:TL-cbs/TL/TL-03-Statements.cbs
P: program ::= decl* statement*

Semantics
	run[[_:program]] :=> null-type
Rule
  run[[D*:decl* S*:statement*]] = 
  scope(collateral(declare-vars[[D*]]) ,execute[[S*]])
=======
  Pgm : program ::= decl

Semantics
  run[[ _:program ]] : =>null-type

Rule
  run[[ D:program ]] = scope(declare-vars[[ D ]], null)
/*
Rule 
  run[[ S:statement ]] = scope((),execute[[S]])
*/
>>>>>>> 11dba2a (TEST NEEDED Variable declaration achieved):TL-cbs/TL/TL-03-Programs
  
Syntax
D: decl ::= 'int' id
Semantics
<<<<<<< HEAD:TL-cbs/TL/TL-03-Statements.cbs
	declare-vars[[_:decl]]:(=> environments)+
=======
  declare-vars[[ _:decl ]] : =>environments
>>>>>>> 11dba2a (TEST NEEDED Variable declaration achieved):TL-cbs/TL/TL-03-Programs
Rule
	declare-vars[['int' ID]] = 
	 bind(id[[ ID ]], allocate-initialised-variable(integers, 0))
Rule
	declare-vars[[D:decl D+:decl+]] = declare-vars[[D]], declare-vars[[D+]]
	

Syntax 
S: statement ::= id '=' aexp
               | 'print' exp

Semantics 
  execute[[S*:statement*]] : => null-type 


Rule 
  execute[[ ID '=' AExp]] = assign(bound(id[[ ID ]]), eval[[ AExp ]])


Rule
  execute[['print' Exp ]] =
    print ( to-string eval[[Exp]], "\n" )

Rule
  execute[[ ]] = null
Rule
  execute[[S S+]] = sequential ( execute[[S]], execute[[S+]] )